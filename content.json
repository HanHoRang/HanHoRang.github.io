{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"About","text":"光有好奇心而不去實踐，等於自願放棄成功機會 別為自己畫地自限，Just Do It！！","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"}],"posts":[{"title":"깃허브 블로그 구축기","text":"Github Blog 구축 기술 블로그용으로 깃허브을 택하여 구축하는 과정에서 생기는 에러에 대한 해결 방법을 정리하였습니다. 제가 참조하여 따라한 링크는 다음과 같으며, 테스트는 Ubuntu16.04 에서 진행하였습니다. Hexo 설치시 에러 ubuntu16.04 에서 Nodejs Version 의존성 문제로 업데이트 필요, NVM 설치 12345678910$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash$ export NVM_DIR=\"$HOME/.nvm\"$ [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\"$ nvm install 10.0$ nvm use 10.0$ hexo install Deployer not found: git : hexo deploy 1npm install hexo-deployer-git --save Config 설정 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/your_github_id/your_github_id.github.io.git branch: master 참고 https://jeyolog.github.io/2018/08/02/hexo-%ED%95%B5%EC%86%8C-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/ https://www.holaxprogramming.com/2017/04/16/github-page-and-hexo/ https://simhyejin.github.io/2016/06/24/hexo-themes/ https://cheese10yun.github.io/blog-start/","link":"/2020/02/21/Github_Blog_구축기/"},{"title":"함수형 언어 in 파이썬","text":"함수형 프로그래밍 함수형 프로그래밍? 상태(변수의 변화하는 값)을 **함수(Evaluating function)**로 대체하여 코드의 간결성과 low-level 수준의 기능을 설계할 수 있다. 이러한 함수(Evaluating function)는 수학 형식과 유사하며 간단한 대수를 사용하여 알고리즘을 설계할 수 있다. 또한 코드가 간결해지는 만큼 효율적이나 상세한 제어 및 정확한 결과를 위해 신중한 디자인이 필요하다. 프로그래밍 패러다임 비교 명령형 프로그래밍: 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식 절차지향 프로그래밍: 수행되어야 할 연속적인 계산 과정을 포함하는 방식 (C, C++) 객체지향 프로그래밍: 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#) 선언형 프로그래밍: 어떤 방법으로 해야 하는지(How)를 나타내기보다 무엇(What)과 같은지를 설명하는 방식 함수형 프로그래밍: 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프) 예시 1부터의 10까지의 정수 중 3와 5의 배수의 값들을 구해보자 절차형 프로그래밍 수행되어야 할 연속적인 계산 과정을 표현, 목표을 위한 알고리즘에 중점 12345# 절차적 프로그래밍 , for 문으로 접근 m = list()for n in range(1, 10): if n % 3 == 0 or n % 5 == 0 : m.append(n) 함수형 프로그래밍 순수 함수를 조합함, 목표에 중점 일련의 숫자의 합, 간단한 테스트 조건(3과 5의 배수) 를 통과하는 값 12345678910111213# 함수형 프로그래밍, 재귀def sum(seq): if len(seq) == 0 : return 0 return seq[0] + sum(seq[1:])def until(n, filter_func, v): if v==n : return [] if filter_func(v): return[v] + until(n, filter_func, v+1) else : return until (n, filter_func, v+1) until(10, lambda x : x%3 == 0 or x%5 ==0 , 0) 하이브리드형 재귀의 기능 단점을 보완 1sum(n for n in range(1, 10) if n %3 ==0 or n%5 == 0) 예시2 제곱근 구하기 (Newton-Raphson 알고리즘) 12def next_(n, x): return (x+n/x) /2 명령형 프로그래밍 123f = lambda x : next_(n, x)a0 = 1.0 [ round(x,4) for x in (a0, f(a0), f(f(a0)), f(f(f(a0))),) ] 함수형 프로그래밍 123456789101112131415def repeat(f, a): yield a for v in repeat(f, f(a)): # 무한 반복 yield v def within(diff, iterable): def head_tail(diff, a, iterable): b = next(iterable) if abs(a-b) &lt;= diff : return b return head_tail(diff, b, iterable) return head_tail(diff, next(iterable), iterable) def sqrt(a0, diff, n): return within(diff, repeat(labmda x : next_(n,x), a0)) 재귀적으로 접근할 때, 목표(diff) 에 초점을 맞춰 코딩이 가능하다 HOW? 순수 함수 커링 1급 함수 순수함수 동일한 입력에는 항상 값은 값을 반환 Side effect(global, nonlocal variable) 에 영향을 받으면 안된다. 123f = lambda x : 2 ** x f(17)131072 러닝 커브가 있지만, 입력 값에 대한 결과를 예상할 수 있어, 테스트에 유용하다 커링, Currying 여러개의 인자를 가진 함수를 호출할 경우, 파라미터의 수보다 적은 수의 파라미터를 인자로 받으면 누락된 파라미터를 인자로 받는다. 12345678910111213141516from pymonad import currydef systolic_bp(bmi, age, gender_mail, treatment): return 68.15+0.58*bmi+0.65*age+0.94*gender_male+6.44*treatmentsystolic_bp(25, 50, 1, 0)systolic_bp(25, 50, 0, 1)# Currying treated = systolic_bp(25,50,0)treated(0)115.15treated(1)121.59 용도에 맞게 쓰기 간편해진다 -&gt; 재사용에 유용해진다 1급 시민 / 1급 객체 / 1급 함수 함수를 인수로 제공하고 다른 함수에 대한 값을 반환 조건 :: 런타임 환경에서 일급 객체여야 한다. (일급 시민 &gt; 일급 객체 &gt; 일급 함수) 1급 조건 변수에 담을 수 있어야 한다 함수의 인자로 전달할 수 있다. 함수의 반환값으로 전달할 수 있다. 12345a = 1 # 변수에 담을 수 있다.def f(num){ # 매개 변수로 전달이 가능하다 result = 1 + a return result # return으로 전달할 수 있다} 12345678910def example(a,b ,**kw): return a*b &gt;&gt;&gt; type(example)&lt; class 'function'&gt;&gt;&gt;&gt; example.__code__.co_varnames('a', 'b', 'kw')&gt;&gt;&gt; example.__code__.co_argcount2 코드 구현이 간결해짐 Closure (go, javascript) 구현 가능 함수를 실행함과 동시에 함수안에 변수가 생성되며 함수를 실행하는 동안 변수는 메모리에 유지된다. 1234567891011121314151617181920package main func nextValue() func() int { i := 0 return func() int { i++ return i }} func main() { next := nextValue() println(next()) // 1 println(next()) // 2 println(next()) // 3 anotherNext := nextValue() println(anotherNext()) // 1 println(anotherNext()) // 2 함수를 호출할 때마다 기존에 생성했던 값을 유지할 수 있다, 변수 재활용 가능 외부에 해당 변수를 노출하지 않음. 전역으로 노출되지는 않지만 전역적인 방식으로 사용이 가능, 안정성이 보장됨 참고 기존의 사고 방식을 깨부수는 함수형 사고 함수형 프로그래밍 요약 functional python programming_pdf [javasript] 1급 시민, 1급 객체, 1급 함수 커링 [javascript] hoisting, scope, closure","link":"/2020/02/21/함수형언어_in_파이썬_/"},{"title":"함수형 언어 모나드편 in 파이썬","text":"모나드 패턴 계산과 원리가 복잡해요! python의 PyMoand 라이브러리 사용하여 모나드 구현 및 이해 Why Pymonad ? PyMonad는 기능 스타일 프로그램을 구현하는 데 사용하기 위해 모나드 및 관련 데이터 추상화 (펑터, 애플리케이션 펑터 및 모노 아이드)를 구현하는 작은 라이브러리입니다. Haskell의 모나드에 익숙한 사람들을 위해 PyMonad는 파이썬에서 모나드를 빠르고 쉽게 사용할 수 있도록 많은 기능을 구현하는 것을 목표로합니다. 모나드를 사용한 적이 없지만 관심이있는 사람들에게 PyMonad는 Haskell을 배울 필요없이 약간 더 용서할 수있는 환경에서 쉽게 배울 수있는 방법입니다. Features 모나드를 이해하기 위해 기본 요소인 Curring의 특징과 합성 함수의 특징을 알아보겠습니다. Currying multiargument function 기능 제공 123456789101112# Returns the first element of a list.@currydef head(aList): return aList[0]# Returns everything except the first element of the list.@currydef tail(aList): return aList[1:]second = head * tail # 'tail' will be applied first, then its result passed to 'head'second([1, 2, 3, 4]) # returns 2 함수를 변수처럼 사용할 수 있다 1234567891011121314151617from pymonad.Reader import curry@currydef add(x, y): return x + y@currydef mul(x, y): return x * ycomp = add(7) * mul(2) # 'mul(2)' is evaluated first, and it's result passed to 'add(7)'comp(4) # returns 15# Composition order matters!comp = mul(2) * add(7)comp(4) # returns 22 커링과 결합하여 합성함수 구현 그렇다면 모나드를 들어가기 전에 왜 함성함수를 사용했을까? 모나드의 기본 요소인 Functor와 Applicative Functor의 원리로 사용되기 때문입니다. Functors, Applicative Functors Functor 함수에서 상태값과 결과 값을 모두 포함하는 기본 요소 Fmap , * 로 표현 1234567891011from pymonad.Maybe import *from pymonad.List import *# 'neg' knows nothing about functor types...def neg(x): return -x# ... but that doesn't stop us from using it anyway.neg * Just(9) # returns Just(-9)neg * Nothing # returns Nothingneg * List(1, 2, 3, 4) # returns List(-1, -2, -3, -4) 인수 ‘9’ 가 들어오면 함수의 결과가 출력되며 Nothing 상태가 들어가면 Nothing 의 결과 값을 알 수 있다. Just 와 List는 Functor 특징을 구현하기 위한 pymonad의 전용 변수와 리스트 자료 구조형임 Applicative Functors Functor 의 Arguments 확장 Amap, &amp; 로 표현 인자 값을 확장하여 사용한다. 12345678910# 'add' operates on simple types, not functors or applicatives...def add(x, y): return x + y# ... but we're going to use it on those types anyway.# Note that we're still using '*' but now in conjunction with '&amp;'add * Just(7) &amp; Just(8) # returns Just(15)add * Nothing &amp; Just(8) # returns Nothingadd * Just(7) &amp; Nothing # returns Nothingadd * List(1, 2, 3) &amp; List(4, 5, 6) # returns List(5, 6, 7, 6, 7, 8, 7, 8, 9) &amp; 연산을 통해 인자 값을 이어 받을 수 있다. Monad Applicative Functors의 확장 Bind, &gt;&gt; 연산자 이용 함수를 확장하여 사용한다. 12345678910111213141516171819202122232425262728from pymonad.List import *from pymonad.Reader import curry# Takes a simple number type and returns a 'List' containing that value and it's negative.def positive_and_negative(x): return List(x, -x)# You can call 'positive_and_negative' normally.positive_and_negative(9) # returns List(9, -9)# Or you can create a List...x = List(9)# ... and then use '&gt;&gt;' to apply positive_and_negative'x &gt;&gt; positive_and_negative # also returns List(9, -9)# But 'x' could also have more than one value...x = List(1, 2)x &gt;&gt; positive_and_negative # returns List(1, -1, 2, -2)# And of course you can sequence partially applied functions.@currydef add_and_sub(x, y): return List(y + x, y - x)List(2) &gt;&gt; positive_and_negative &gt;&gt; add_and_sub(3) # List(2) # List(2, -2) # List(5, -1, 1, -5) 함수 확장을 이용 &gt;&gt; 를 이용, positive_and_negative의 인자 값으로 List(2) 을 이용하여 List(2,-2)의 결과값을 얻음 List(2, -2)가 add_and_sub(3) 의 인자값으로 들어가 List(5, -1, 1, -5)의 결과 값을 받음 Monadic code &gt;&gt; 연산자 이용 함수를 람다로 대체하여 이후에 함수 구현이 가능하다 12345from pymonad.Maybe import *Just(9) &gt;&gt; (lambda x: # Here, 'x' takes the value '9'Just(8) &gt;&gt; (lambda y: # And 'y' takes the value '8'Just(x + y))) # 'Just(9 + 8)' or 'Just(17)' State Monad 12345678910111213141516171819202122@currydef add(x, y): return State(lambda old_state: (x + y, old_state + 1))@currydef subtract(y, x): @State def state_computation(old_state): if x - y &lt; 0: return (0, old_state + 1) else: return (x - y, old_state + 1) return state_computation x = unit(State, 1) &gt;&gt; add(2) &gt;&gt; add(3) &gt;&gt; subtract(40) &gt;&gt; add(5)y = x(0)print(y)y = x.getResult(0) # computation result value 5 y = x.getState(0) # state value 4 old_state로 돌아 갈 수 있어서 State 패턴이라 칭함 Functional programming to Web Sever 1headers, contents = httpd(headers, request, [uploads]) 최적화 참고 PyMonad 함수형 프로그래밍 in Python WikibooksHaskell 위키북스 모나드 이해하기","link":"/2020/02/21/함수형언어_모나드_in_파이썬_.md/"},{"title":"Facade Pattern","text":"디자인 패턴 객체 지향 프로그래밍 설계에서 자주 발생하는 문제들을 피하기 위해 사용되는 패턴 다만, 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론이며 모든 상황의 해결책은 아니다. 중요한 것은 디자인 패턴에 얽매이는 것이 아니라 그 패턴이 왜 효율적인 방식인지를 이해하여야 한다. 파사드(Facade) 패턴 복잡한 서브시스템을 인터페이스 감싸 간단하게 만드는 패턴이며 3의 API(Third Party API)같은 외부 라이브러리를 추상화 하는데도 사용됩니다. 프로젝트 전체에 특정한 코드가 부분적으로 분포되어 있을 경우 유지보수에 탁월하다. 123456789101112package ThirdPartyAPI;public class DatabaseClient { public DatabaseClient () { } public void find(final String table, final String primaryKey, final Integer maxRetry) { // Database Request to the DB Server }} 12345678910111213import ThirdPartyAPI.DatabaseClient;public class ItemService {private final DatabaseClient databaseClient;public ItemService() {databaseClient = new DatabaseClient();}public void find(final String primaryKey) {databaseClient.find(\"Item\", primaryKey, 3);}} DatabaseClient 가 version Update되어 find 함수의 매개변수가 달라진 경우, DatabaseClient를 감싸고 있는 ItemService 의 호출부분만 변경해주면 된다. 123456789101112public class ItemService { private final DatabaseClient databaseClient; public ItemService() { databaseClient = new DatabaseClient(); } public void find(final String primaryKey) { DatabaseOption databaseOption = new DatabaseOption.Builder(\"Item\") .withPrimaryKey(primaryKey).withMaxRetry(3).build(); databaseClient.find(databaseOption); } 만약 파사드 패턴이 아니였다면? 코드를 고친 곳의 유닛테스트를 전부 다시 해야 한다. 그리고 유닛테스트를 모두 고친 후 인테그레이션 테스트를 했어야 할 것이다. 테스팅 시간이 길다면 헬게이트 오픈 참고 디자인 패턴이란 나무위키_디자인패턴 itertools ㅍㅍㅋㄷ - 이터레이터, 제너레이터 python 2.2 doc 디자인 패턴 - 실무편 파사드 패턴 - 협업 파사드 패턴 - Logbridge","link":"/2020/02/21/Facade_Pattern/"},{"title":"Iterator Pattern","text":"디자인 패턴 객체 지향 프로그래밍 설계에서 자주 발생하는 문제들을 피하기 위해 사용되는 패턴 다만, 알고리즘이 아니라 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론이며 모든 상황의 해결책은 아니다. 중요한 것은 디자인 패턴에 얽매이는 것이 아니라 그 패턴이 왜 효율적인 방식인지를 이해하여야 한다. 이터레이터(iterator) 패턴 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용할 수 있도록 해준다. 파이썬의 경우, 이터레이터와 제너레이터를 묶어 문법으로 소개되어 있습니다. 12345678910111213141516171819202122# 이터레이터def __getitem__(self, index): return &lt;next item&gt;&gt;&gt;&gt; L = [1,2,3]&gt;&gt;&gt; i = iter(L)&gt;&gt;&gt; print i&lt;iterator object at 0x8116870&gt;&gt;&gt;&gt; i.next()1&gt;&gt;&gt; i.next()2&gt;&gt;&gt; i.next()3&gt;&gt;&gt; i.next()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in ?StopIteration&gt;&gt;&gt;for x in [1,2,3]: print(x) 굳이 iter() 함수를 사용하지 않아도 for 문으로 접근이 가능하다. 이것은 looping 하는 동안, python 내부에서 임시로 list를 iterator로 자동으로 변환됨 123456789101112131415161718192021222324252627282930313233# generatordef generate_ints(N): for i in range(N): yield i # generator expression&gt;&gt;&gt; ( i for i in xrange(10) if i % 2 )&lt;generator object &lt;genexpr&gt; at 0x7f6105d90960&gt;#1 제너레이터 사용 이유, 메모리 &gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getsizeof( [i for i in xrange(100) if i % 2] ) # list536&gt;&gt;&gt; sys.getsizeof( [i for i in xrange(1000) if i % 2] )4280&gt;&gt;&gt; sys.getsizeof( (i for i in xrange(100) if i % 2) ) # generator80&gt;&gt;&gt; sys.getsizeof( (i for i in xrange(1000) if i % 2) )80#2 제너레이터 사용 이유, Lazy evaluation def fibonacci_func(n): a,b = 0, 1 i = 0 while True: if (i &gt; n): return yield a a, b = b, a+b i += 1fib = fibonacci_func(10)for x in fib: print x #1 Memory 를 효율적으로 사용할 수 있다. list 는 list 안에 속한 모든 데이터를 메모리에 적재하기 때문에 list의 크기 만큼 차지하는 메모리 사이즈가 늘어나게 된다. 하지만 generator 의 경우 데이터 값을 한꺼번에 메모리에 적재 하는 것이 아니라 next() 메소드를 통해 차례로 값에 접근할 때마다 메모리에 적재하는 방식이다. #2 Lazy evaluation 지원, 메모리상의 효율성 및 불필요한 연산의 배제가 가능하여 효율적인 퍼포먼스를 기대할 수 있다. itertools 라이브러리에서 다양한 이터레이터의 활용 예(iterator building block)를 확인할 수 있습니다. Infinite Iterators: Iterator Arguments Results Example count() start, [step] start, start+step, start+2*step, … count(10) --&gt; 10 11 12 13 14 ... cycle() p p0, p1, … plast, p0, p1, … cycle('ABCD') --&gt; A B C D A B C D ... repeat() elem [,n] elem, elem, elem, … endlessly or up to n times repeat(10, 3) --&gt; 10 10 10 Iterators terminating on the shortest input sequence: Iterator Arguments Results Example chain() p, q, … p0, p1, … plast, q0, q1, … chain('ABC', 'DEF') --&gt; A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F dropwhile() pred, seq seq[n], seq[n+1], starting when pred fails dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1 groupby() iterable[, keyfunc] sub-iterators grouped by value of keyfunc(v) ifilter() pred, seq elements of seq where pred(elem) is true ifilter(lambda x: x%2, range(10)) --&gt; 1 3 5 7 9 ifilterfalse() pred, seq elements of seq where pred(elem) is false ifilterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8 islice() seq, [start,] stop [, step] elements from seq[start:stop:step] islice('ABCDEFG', 2, None) --&gt; C D E F G imap() func, p, q, … func(p0, q0), func(p1, q1), … imap(pow, (2,3,10), (5,2,3)) --&gt; 32 9 1000 starmap() func, seq func(*seq[0]), func(*seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000 tee() it, n it1, it2, … itn splits one iterator into n takewhile() pred, seq seq[0], seq[1], until pred fails takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4 izip() p, q, … (p[0], q[0]), (p[1], q[1]), … izip('ABCD', 'xy') --&gt; Ax By izip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … izip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D- Combinatoric generators: Iterator Arguments Results product() p, q, … [repeat=1] cartesian product, equivalent to a nested for-loop permutations() p[, r] r-length tuples, all possible orderings, no repeated elements combinations() p, r r-length tuples, in sorted order, no repeated elements combinations_with_replacement() p, r r-length tuples, in sorted order, with repeated elements product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD 그 외에도 이터레이터에 Map, fliter, reduce &amp; lambda 를 사용하여 이터레이터와 함수간 매핑이 가능합니다. 1234567891011# map items = [1,2,3,4,5]list(map(lambda x : x**2, items))# filternumber_list = raunge(-5, 5)list(filter(lambda x : x&lt;0, number_list))# reducefrom functools import reduce value = reduce((lambda x,y : x+y), (x for x in range(1, 101)) 제너레이터 장점(메모리, Lazy) + 함수형 언어(간결성, Lazy) 참고 디자인 패턴이란 나무위키_디자인패턴 itertools ㅍㅍㅋㄷ - 이터레이터, 제너레이터 python 2.2 doc 디자인 패턴 - 실무편 파사드 패턴 - 협업 파사드 패턴 - Logbridge","link":"/2020/02/21/Iterator_Pattern/"},{"title":"Observer Pattern","text":"디자인 패턴 중요한 것은 디자인 패턴에 얽매이는 것이 아니라 그 패턴이 왜 효율적인 방식인지를 이해하여야 한다. 디자인 패턴 두 번째 발표자료이며 싱글턴, 옵저버 패턴에 대해 발표하겠습니다. 저는 저번 시간과 같이 패턴에 대해 다음과 같은 관점으로 접근하였습니다. 패턴이 된 원인(어떤 점이 효율적인가), 보완해야할 점(to 잡기술 배우기) 패턴이 현대 프로그래밍 언어에서는 어떻게 사용되는가? 옵저버 패턴 옵저버 패턴(observer pattern)은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴 입니다. **왜 사용할까 ? ** 객체 간의 일대 다 종속성 관계를 관리할 때 사용됩니다. 객체 간의 밀접한 관계없이 객체 간의 일대 다 종속성을 정의해야 합니다. 하나의 객체가 상태를 변경할 때 개방형 수의 종속 객체가 자동으로 업데이트되도록 해야합니다. 한 객체가 개방 된 수의 다른 객체를 통지 할 수 있어야합니다. 어떻게 구현할까? 12345678910111213141516171819202122class Observable(object): def __init__(self) -&gt; None: self._observers = [] def register_observer(self, observer) -&gt; None: self._observers.append(observer) def notify_observers(self, *args, **kwargs) -&gt; None: for observer in self._observers: observer.notify(self, *args, **kwargs)class Observer(object): def __init__(self, observable) -&gt; None: observable.register_observer(self) def notify(self, observable, *args, **kwargs) -&gt; None: print('Got', args, kwargs, 'From', observable)subject = Observable()observer = Observer(subject)subject.notify_observers('test') 주체에 따라 Push, Pull 방식으로 나눠집니다. (자료 보강 필요 ㅠㅠ) 한계 하지만, 옵저버 패턴의 한계도 존재합니다. 개체 간의 일대 다 종속성 정의는 대상을 특정 종속 개체에 연결하기 때문에 융통성이 없습니다. 이는 성능이 필요한 상황에서는 (초당 수천 번 실행되는 저수준 커널 구조를 고려할 때) 고민해봐야할 문제입니다. 밀접하게 연결된 객체는 일부 시나리오에서 구현하기가 어려울 수 있으며 인터페이스가 다른 여러 객체를 참조하고 업데이트하는 방법을 알고 있기 때문에 재사용 할 수 있어 기대하지 않은 결과를 초래할 수 있습니다. 또한, 옵저버 패턴인 경우 메모리 누수를 초래할 수 있습니다. So what can possibly go wrong? In a runtime where memory is managed automatically like Java or C#, the subject holds a strong reference to the observers, keeping them alive. The strong reference from the subject (the observed object) to the observer, prevents the observer (and any objects it references) from being garbage collected until the observer is unregistered. A memory leak happens, if the observer fails to unregister from the subject when it no longer needs to receive notifications. In our countdown timer example if observers do not call unregister when they become invisible, they will receive notifications and waste CPU cycles updating invisible UI elements. This issue is called Lapsed Listener Problem. If you implement the observer pattern in C++ (no garbage collection, memory is managed manually) and you call delete on one of the observers without unregistering it from the subject then you are in trouble. Now you have a dangling pointer that points to invalid data. Whenever the subject notifies its observers a segmentation fault will be raised. Always unregister your listeners unless they are interested in receiving notifications. Another approach for dealing with lapsed listeners (observers) is to use Weak References. The below implementation of CountDownTimer uses weak references to keep track of registered observers. If the only references to an instance are weak references, then the instance becomes a candidate for Garbage Collection. In contrast to strong references, weak references don’t prevent garbage collector to finilize the instance and reclaim its memory. 사실 이는 옵저버 패턴뿐만 아니라 OOP 객체를 다룰 때 공통적으로 발생할 수 있는 문제입니다. 단적인 해결방법은 Weakreference 를 사용하여 수동적으로 가비지 컬렉션을 사용한다고 명시하면 예방할 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package codekata.observer;import java.lang.ref.WeakReference;import java.util.LinkedList;import java.util.List;public class CountDownTimer { private static long ONE_SECOND = 1000L; private long countDownMillis; private long elapsedTimeSinceLastTick; private long totalElapsedTime; private List&lt;WeakReference&lt;CountDownObserver&gt;&gt; observers = new LinkedList&lt;&gt;(); public CountDownTimer(long initialValue) { this.countDownMillis = initialValue; } //Called every frame public void update(long deltaTime) { if (isFinished()) { return; } if (totalElapsedTime == 0) { notifyStart(); } totalElapsedTime += deltaTime; elapsedTimeSinceLastTick += deltaTime; if (elapsedTimeSinceLastTick &gt;= ONE_SECOND) { elapsedTimeSinceLastTick = 0; notifyCountDown(); } if (isFinished()) { notifyCountDown(); notifyFinish(); } } private boolean isFinished() { return totalElapsedTime &gt;= countDownMillis; } private void notifyCountDown() { for(WeakReference&lt;CountDownObserver&gt; ref : this.observers) { CountDownObserver observer = ref.get(); if (observer != null) { observer.onCountDown( totalElapsedTime, Math.max(0, (countDownMillis - totalElapsedTime))); } else { System.out.println(\"!!! DELETED\"); } } } private void notifyStart() { for(WeakReference&lt;CountDownObserver&gt; ref : this.observers) { CountDownObserver observer = ref.get(); if (observer != null) { observer.onStart(); } } } private void notifyFinish() { for(WeakReference&lt;CountDownObserver&gt; ref : this.observers) { CountDownObserver observer = ref.get(); if (observer != null) { observer.onFinish(); } } } public void registerObserver(CountDownObserver observer) { WeakReference&lt;CountDownObserver&gt; weakReference = findWeakReference(observer); if (weakReference == null) { weakReference = new WeakReference&lt;&gt;(observer); this.observers.add(weakReference); } } public void unregisterObserver(CountDownObserver observer) { WeakReference&lt;CountDownObserver&gt; weakReference = findWeakReference(observer); if (weakReference != null) { this.observers.remove(weakReference); } } private WeakReference&lt;CountDownObserver&gt; findWeakReference(CountDownObserver observer) { WeakReference&lt;CountDownObserver&gt; weakReference = null; for(WeakReference&lt;CountDownObserver&gt; ref : this.observers) { if (ref.get() == observer) { weakReference = ref; } } return weakReference; }} 자바 고수의 도움이 필요합니다. 그럼에도 불구하고… 옵저버 패턴에서의 객체 관리는 링크리스트 로 저장합니다. 하지만 이는 단일 스레드에서만 해당되는 예기로 멀티스레드 상황에서 Thread-safe 상황을 보장하지 못합니다. 그렇다면 어디에 사용해볼까? 대표적으로 MVC 아키텍처에서 사용할 수 있습니다. MVC 는 Model-View-Controller 로 소프트웨어 디자인 패턴입니다. 사용자 인터페이스로부터 비지니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있습니다. ![Observer Pattern](C:\\Users\\user\\Desktop\\공부\\CS Study\\Design Pattern\\Observer Pattern.PNG) Model은 애플리케이션의 정보(데이터)를 나타내며,View는 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타내고, Controller는 데이터와 비즈니스 로직 사이의 상호동작을 관리한다. MVC가 활용된 예로 Qt, MFC 프레임워크가 있는 데 MFC 프레임워크에서의 옵서버 패턴 사용을 살펴보겠습니다. ![MFC1](C:\\Users\\user\\Desktop\\공부\\CS Study\\Design Pattern\\MFC1.PNG) 먼저 뷰를 원하는 곳에 배치합니다. ![MFC2](C:\\Users\\user\\Desktop\\공부\\CS Study\\Design Pattern\\MFC2.PNG) 뷰를 배치함과 동시에 컨트롤러 코드가 자동으로 생성됩니다. ![MFC3](C:\\Users\\user\\Desktop\\공부\\CS Study\\Design Pattern\\MFC3.PNG) 컨트롤러 코드를 작성하여 이벤트가 발생했을 시 구현할 내용을 작성합니다. 사용처? MVC 같은 경우 기능의 On/OFF 인 상태가 다수일 경우 사용하기 좋습니다. 곰플레이어에서의 동영상 관련 기능 이벤트나 한글의 여러 기능을 예로 생각하면 이해하기 편할 것 같습니다. 참고 위키백과 옵서버패턴 옵서버 방식 두가지 https://doohyun.tistory.com/82 로깅 - 옵저버 vs 책임연쇄 옵서버패턴에서의 메모리릭 https://glikmakesworld.tistory.com/3 예시 https://nowonbun.tistory.com/480 실무","link":"/2020/02/21/Observer_Pattern/"},{"title":"Singleton Pattern","text":"디자인 패턴(2) 중요한 것은 디자인 패턴에 얽매이는 것이 아니라 그 패턴이 왜 효율적인 방식인지를 이해하여야 한다. 디자인 패턴 두 번째 발표자료이며 싱글턴, 옵저버 패턴에 대해 발표하겠습니다. 저는 저번 시간과 같이 패턴에 대해 다음과 같은 관점으로 접근하였습니다. 패턴이 된 원인(어떤 점이 효율적인가), 보완해야할 점(to 잡기술 배우기) 패턴이 현대 프로그래밍 언어에서는 어떻게 사용되는가? 싱글턴 패턴 싱글턴 패턴(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다. [위키미러] 왜 사용할까 ? 클래스 내에서 인스턴스가 단 하나뿐임을 보장하므로, 프로그램 전역에서 해당 클래스의 인스턴스를 바로 얻을 수 있고, 불필요한 메모리 낭비를 최소화한다. 어떻게 구현할까 ? __new__ 생성자 와 메타클래스 를 통해 구현한 싱글턴 123456789101112131415class Singleton(object): def __new__(self): if not hasattr(self, 'instance'): self.Instance = super(Singleton, self).__new__(self) return self.self.instance s = singleton()s2 = singleton()print(\"Object created\", s)print(\"Object created\", s2)outputObject created &lt;__main__.Singleton object at 0x0000028014344EF0&gt;Object created &lt;__main__.Singleton object at 0x0000028014344EF0&gt; python 의 __new__ 생성자를 사용하여 싱글턴 구현 __new__ ? __init__ 이 반환 값을 가질 수 없는 것을 보완한 생성자 1234567891011class MetaSingleton(type): _instances = {} def __call__(self, *args, **kwargs): if self not in self._instances: self._instances[self] = super(MetaSingleton, self).__call__(*args, **kwargs) return self._instances[self] class Logger(metaclass = MetaSingleton): pass 싱글턴 변형, 객체는 다르지만 상태를 공유함 1234567891011121314151617class Singleton2: __shard_state = {\"1\":\"2\"} def __init__(self): self.x = 1 self.__dict__ = self.__shared_state pass b1 = Singleton2();b2 = Singleton2();b1.x = 5output&lt;__main__.LazySingleton object at 0x0000028014357F60&gt;&lt;__main__.LazySingleton object at 0x0000028014357F98&gt;{'1': '2', 'x': 5}{'1': '2', 'x': 5} 싱글턴의 문제점 싱글턴 인스턴스가 많은 일을 하거나 데이터를 공유시킬 경우 다른 클래스의 인스턴스들간의 결합도가 높아져 OOP 원칙, &quot;개방-폐쇠 원칙&quot;을 위해하게 된다. 따라서 수정이 어려워지고 테스트하기 어려워진다. 또한, 멀티쓰레드 환경에서 동기화처리를 안하면 인스턴스가 두 개가 생성되는 경우가 발생할 수 있음 결과적으로 ‘goto는 쓰면 안돼’ , ‘전역 객체는 안좋은거야!’ 라는 말 처럼 꼭 필요한 경우가 아니면 지양해야한다. 멀티쓰레드에서 안전한 싱클톤 클래스 생성하기 Java 테스트했으며 3가지의 방법을 소개하겠습니다. Synchronized 를 통한 Thread safe Lazy initialization(게으른 초기화) 1234567891011121314public class ThreadSafeLazyInitialization{ private static ThreadSafeLazyInitialization instance; private ThreadSafeLazyInitialization(){} public static synchronized ThreadSafeLazyInitialization getInstance(){ if(instance == null){ instance = new ThreadSafeLazyInitialization(); } return instance; } } private 생성자로 외부에서의 생성을 막았으나, synchronized 특성상 큰 성능저하가 발생하므로 권장하지 않는다 Synchronized 대신 가정문 사용하기, Thread safe lazy initialization + Double-checked locking 123456789101112131415161718public class ThreadSafeLazyInitialization { private volatile static ThreadSafeLazyInitialization instance; private ThreadSafeLazyInitialization(){} public static ThreadSafeLazyInitialization getInstance(){ if(instance == null){ synchronized (ThreadSafeLazyInitialization.class) { if(instance == null) instance = new ThreadSafeLazyInitialization(); } } return instance; }} synchronized 를 사용하는 것이 아니라 If 문 두번(확인, 동기화)으로 성능 저하를 피했지만 완벽한 방법(개발자가 직접 문제를 회피해야할 코드를 짜야함)은 아닙니다. final 을 사용한 Initialization on demand holder idiom 123456789101112public class Something { private Something() { } private static class LazyHolder { public static final Something INSTANCE = new Something(); } public static Something getInstance() { return LazyHolder.INSTANCE; }} 개발자가 직접 동기화 문제에 대해 코드를 작성하여 문제를 회피하려 한다면 프로그램 구조가 그 만큼 복잡해지고 비용 문제가 생길 수 있고 특히 유지보수 측면에서 이상적이지 못합니다. 이 방법은 JVM의 클래스 초기화 과정에서 보장되는 원자적 특성을 이용하여 싱글턴의 초기화 문제에 대한 책임을 JVM에 떠넘긴다. holder안에 선언된 instance가 static이기 때문에 클래스 로딩시점에 한번만 호출될 것이며 final을 사용해 다시 값이 할당되지 않도록 만든 방법. *** 가장 많이 사용하고 일반적인 Singleton 클래스 사용 방법이다.** 현 트렌드에서의 싱글턴? 여기까지 살펴보았을 때, 배(그냥 코드로 사용하기)보다 배꼽(싱글턴 패턴 사용)이 더 큰 상황이라 느꼈습니다. 그래서 현업에서는 싱글턴을 사용해야할 상황일 때 실제 사용하나? 가 궁금해서 생각해봤습니다. 위키미러를 참고했을 때 싱글턴의 활용처는 DBCP(DataBase Connection Pool)와 같은 상황입니다. 그러면 현 트랜드에서는 DBCP를 싱글턴을 통해 활용하고 있을까요? 답변부터 드리면, 구글(go, Kotlin)에서는 싱글턴의 Initialization on demand holder idiom 을 문법으로 구현하는 추세입니다. go - Once.do 활용 12345678910111213141516171819202122232425262728293031323334353637var once sync.Oncetype DriverPg struct { conn string}// variavel Globalvar instance *DriverPgfunc Connect() *DriverPg { once.Do(func() { instance = &amp;DriverPg{conn: \"DriverConnectPostgres\"} //DB 연결 처리 }) return instance}func main() { // chamada go func() { time.Sleep(time.Millisecond * 600) fmt.Println(*Connect()) }() // 100 goroutine for i := 0; i &lt; 100; i++ { go func(ix int) { time.Sleep(time.Millisecond * 60) fmt.Println(ix, \" = \", Connect().conn) }(i) } fmt.Scanln()} 동기라이브러리안 Once keyword 이용하여 Initialization on demand holder idiom 구현 kotlin- Object 활용 123456789101112object Payroll { //object 클래스 생성으로 싱글턴을 구현 val allEmplyees = arrayListOf&lt;Person&gt;() fun calculateSalary() { //... }}//사용Payroll.calculateSalary() //싱글턴처럼 . 으로 접근Payroll.allEmplyees.add(Person(\"zerog\", Company(\"zerog\", Address(\"\")))) 객체(Object)는 클래스 선언과 그 클래스에 속한 단일 인스턴스의 생성을 동시에 처리해주기 때문에 싱글톤에 사용하기 적합합니다. double-checked locking 같은 locking 알고리즘에 의존하는 것 없이 thread-safe 하고 lazy 한 초기화를 가능하게 해 주기 때문에 JVM에서 싱글톤을 구현하는 방법으로 선호됩니다. 코틀린에서 간단하게 object를 선언하면, 안전하고 효율적인 싱글톤 구현을 보장받을 수 있습니다. 정리 싱글톤의 원리와 구현방법을 살펴보았습니다. 전역 객체를 생성하여 접근하여 메모리 측면의 효율성을 기대하는 패턴이지만, 쓰레드에서의 싱글톤과 OOP 기법의 안정성을 위해 Initialization on demand holder idiom 기법을사용하여 싱글톤을 구현하는 것이 바람직합니다. 더불어 현 구글 언어(go, kotilin)에서는 해당 기법이 문법으로 소개되어있으며 사용하시는 데 참고하시면 되겠습니다. 참고 위키백과_싱글턴 패턴 https://tourspace.tistory.com/109 https://takhyeongmin.github.io/2019/06/24/HowToKotlinSingleTon/ https://fenderist.tistory.com/109 https://www.fun-coding.org/PL&amp;OOP2-2.html 기본적인 싱글톤 구현방법 5가지 싱글톤의 고도화 싱글톤 문제점과 3가지 해결방안 고랭-싱글톤 코틀린-싱글톤","link":"/2020/02/21/SingleTon_Pattern/"},{"title":"Strategy Pattern","text":"디자인 패턴 중요한 것은 디자인 패턴에 얽매이는 것이 아니라 그 패턴이 왜 효율적인 방식인지를 이해하여야 한다. 디자인 패턴 세 번째 발표자료이며 스트레티지, 팩토리 패턴에 대해 발표하겠습니다. 저는 저번 시간과 같이 패턴에 대해 다음과 같은 관점으로 접근하였습니다. 패턴이 된 원인(어떤 점이 효율적인가), 보완해야할 점(to 잡기술 배우기) 패턴이 현대 프로그래밍 언어에서는 어떻게 사용되는가? 스트레티지 패턴 전략 패턴 (정책 패턴이라고도 함)은 런타임시 알고리즘을 선택할 수있는 행동 소프트웨어 디자인 패턴입니다. 코드는 단일 알고리즘을 직접 구현하는 대신 알고리즘 계열에서 사용할 알고리즘에 대한 런타임 명령을 수신합니다. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 알고리즘이 독립적으로 달라질 수 있습니다. 전략은 감마 (Gamma) 등의 영향력있는 책 디자인 패턴에 포함 된 패턴 중 하나입니다. 유연하고 재사용 가능한 객체 지향 소프트웨어를 디자인하는 방법을 설명하기 위해 디자인 패턴을 사용하는 개념을 대중화했습니다. 런타임까지 사용할 알고리즘에 대한 결정을 연기하면 호출 코드를보다 유연하고 재사용 할 수 있습니다. 예를 들어, 들어오는 데이터에 대한 유효성 검사를 수행하는 클래스는 전략 유형을 사용하여 데이터 형식, 데이터 소스, 사용자 선택 또는 기타 식별 요소에 따라 유효성 검사 알고리즘을 선택할 수 있습니다. 이러한 요소는 런타임까지 알려지지 않았으며 완전히 다른 유효성 검사를 수행해야 할 수도 있습니다. 유효성 검사 객체와 별도로 캡슐화 된 유효성 검사 알고리즘 (전략)은 코드 복제없이 시스템 (또는 다른 시스템)의 다른 영역에있는 다른 유효성 검사 객체에 의해 사용될 수 있습니다. 일반적으로 전략 패턴은 일부 코드에 대한 참조를 데이터 구조에 저장하고 검색합니다. 이는 네이티브 함수 포인터, 1 급 함수, 객체 지향 프로그래밍 언어의 클래스 또는 클래스 인스턴스와 같은 메커니즘 또는 리플렉션을 통해 언어 구현의 내부 코드 저장소에 액세스하여 달성 할 수 있습니다. UML 전략패턴의 필요성과 구현 전략 패턴을 왜 필요하고, 어떻게 구현할 것 인지 간단한 예제로 설명하겠습니다.다음 예제는 캐릭터가 무기를 가지고 공격하는 클래스를 구현한 예제입니다. 언어는 파이썬입니다. 123456class Character: def __init__(): self.weapon = new Knife() def doAttack(): print(\"Attack Knife!!\") Knife().Attack() 실행상 아무 문제없지만, “캐릭터는 단검에 의존된 형태” 입니다. 만약 캐릭터에 검을 장착시키고 싶다면 어떻게 해야할까요? 123456class Character: def __init__(): self.weapon = new Sword() def doAttack(): print(\"Attack Sword!!\") Sword().Attack() 야메로 코드를 변경하여 캐릭터에 검을 장착하였습니다. 하지만 단검과 검을 변경해야하는 캐릭터가 필요하면? 헬게이트 오픈이 예상됩니다변경 요청이 발생할 때마다 코드를 수정해야 합니다. 유지보수가 어려워지며 이는 캐릭터가 무기에 의존되있어 발생합니다. 이를 스프링 프레임워크에서 사용하는 개념으로 설명하자면 DI:Dependency Injection, 의존성 주입 라 합니다. 의존성을 깨드리기 위해선 어떻게 해야할까요? 간단합니다. Weapon 을 클래스로 만들어 캡슐화시키면 됩니다. 캡슐화를 위해 인터페이스를 사용하였습니다. 인터페이스는 클래스는 확장을 위해 open/closed principle(OCP)와 호환되며, 동작을 사용하는 클래스를 중단하지 않고 동작을 변경할 수 있으며, 중요한 코드 변경없이 사용 된 특정 구현을 변경하여 클래스가 동작간에 전환 할 수 있습니다. 디자인 타임뿐만 아니라 런타임에도 동작을 변경할 수 있습니다. 인터페이스를 통해 구현된 예제는 다음과 같습니다. open/closed principle(OCP), 개방 / 폐쇄 원칙 : 클래스는 확장을 위해 개방되어야하지만 수정을 위해 폐쇄되어야한다는 원칙입니다. 1234567891011121314151617181920212223242526272829303132import abc class Weapon: __metaclass__ = abc.ABCMeta @abc.abstractmethod def doAttack(self): passclass Knife(Weapon): def doAttack(self): print(\"Attack Knife!!\")class Sword(Weapon): def doAttack(self): print(\"Attack Sword!!\")class Character: def __init__(self, weapon): super(Character, self).__init__() self.weapon = weapon def setWeapon(self,weapon): self.weapon = weapon def doAttack(self): self.weapon.doAttack()c = Character(Knife())c.doAttack()c.setWeapon(Sword())c.doAttack() 앞서 무기 변경 요청에 대해 메인 함수에서 결정할 수 있게 되었습니다. 즉 무기를 제어하는 제어권이 캐릭터에 있는 것이 아니라 메인 함수로 역전되었으므로 이를 제어가 역전되었다라고 하며 스프링에서 사용하는 기술 영어로 IOC:Inversion of Control, 제어의 역전 이라 합니다. 그렇다면 지금은? 사실 파이썬에서는 객체화를 통해 전략 패턴을 구현할 필요는 없습니다. 함수 자체를 변수화시키면 매우 깔끔하고 간단한 전략 패턴을 구현할 수 있거든요. 다음은 Pycon 2009 의 디자인 패턴으로 소개된 전략 패턴 예제입니다. 12345678910def strategy_add(a, b): return a + bdef strategy_minus(a, b): return a - bsolver = strategy_addprint solver(1, 2)solver = strategy_minusprint solver(2, 1) 매우 깔끔하도다 ! 전략 패턴을 넘어서 앞서 전략 패턴의 소개로 런타임시 알고리즘을 선택할 수있는 행동 소프트웨어 디자인 패턴으로 이를 IOC:Inversion of Control, 제어의 역전이라고 소개드렸습니다. 저는 전략 패턴이외에도 Ioc 를 구현할 수 있는 방법으로 서버리스 아키텍처가 있다 생각하여 생각하여 하나의 예제를 소개하고자 합니다. 전자부품연구원에서 서버리크 아키텍처 연구과제로 개발 중인 Openfx의 아키텍처 입니다. 기능적 유사 프레임워크로 AWS의 람다라고 생각하시면 편할 것 같습니다. 사용자가 서버의 제약없이 구현부의 코드만 개발하여 해당 프레임워크에 배포하면 자동으로 서버로 묶여 실행되는 구조입니다. 어떻게 구현되는 것일까요? 아래 예제는 Openfx의 아키텍처에서 Openfx-fn 에서 Executer 의 서버 구현 코드를 일부 가져왔습니다. 1234567891011121314151617import impdef loadPlugin(moduleName, funcName): mod = imp.load_source(funcName, moduleName) # load user function from module return getattr(mod, funcName)def serve(): server = grpc.server(futures.ThreadPoolExecutor(max_workers=10)) watcherServer = FxWatcherServicer(loadPlugin(moduleName, funcName)) fxwatcher_pb2_grpc.add_FxWatcherServicer_to_server( watcherServer, server) server.add_insecure_port('[::]:'+fxwatcherPort)if __name__ == '__main__': serve() 핵심은 imp 라이브러리에서 제공하는 loadPlugin 기능입니다. 외부 라이브러리의 함수를 변수로 받아 Server로 등록하는 기능을 수행하며, 런타임시 임의의 함수를 불러와 서버에 등록하여 서버를 시작합니다. 이외에도 도커의 이미지 기술을 활용하여 런타임시간을 늦춰 사용자 함수를 배포할 때 서버의 이미지와 묶여 서버로 실행되는 구조를 가지고 있습니다. 전략 패턴의 활용 다음은 동일한 메소드를 가진 클래스들에 대해 어떻게 사용되고 있는 지, gRPC Server의 구현 코드 예제를 보면서 설명하겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// A ServerOption sets options such as credentials, codec and keepalive parameters, etc.type ServerOption interface { apply(*serverOptions)}// 기본 type EmptyServerOption struct{}func (EmptyServerOption) apply(*serverOptions) {}// 사용자 옵션을 위한 구조체 type funcServerOption struct { f func(*serverOptions)}// 사용자 옵션 함수 실행func (fdo *funcServerOption) apply(do *serverOptions) { fdo.f(do)}// 사용자 옵션 생성 함수func newFuncServerOption(f func(*serverOptions)) *funcServerOption { return &amp;funcServerOption{ f: f, }}func NewServer(opt ...ServerOption) *Server { opts := defaultServerOptions for _, o := range opt { o.apply(&amp;opts) } s := &amp;Server{ lis: make(map[net.Listener]bool), opts: opts, conns: make(map[transport.ServerTransport]bool), m: make(map[string]*service), quit: grpcsync.NewEvent(), done: grpcsync.NewEvent(), czData: new(channelzData), } chainUnaryServerInterceptors(s) chainStreamServerInterceptors(s) s.cv = sync.NewCond(&amp;s.mu) if EnableTracing { _, file, line, _ := runtime.Caller(1) s.events = trace.NewEventLog(\"grpc.Server\", fmt.Sprintf(\"%s:%d\", file, line)) } if channelz.IsOn() { s.channelzID = channelz.RegisterServer(&amp;channelzServer{s}, \"\") } return s} apply 를 하면 뭐가 달라지는 건데? … 참고 위키백과_전략패턴 제어의 역전과 의존성 주입 간단 정리 파이콘 2009_ 다자인 패턴 소개 전자부품연구원 서버리스 아키텍처, Openfx github gRPC github","link":"/2020/03/05/Strategy_Pattern/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Functional Programming","slug":"Functional-Programming","link":"/tags/Functional-Programming/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"}],"categories":[]}